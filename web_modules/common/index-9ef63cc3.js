function k(){}function X(t,e){for(const n in e)t[n]=e[n];return t}function G(t){return t()}function I(){return Object.create(null)}function b(t){t.forEach(G)}function Y(t){return typeof t=="function"}function Z(t,e){return t!=t?e==e:t!==e||t&&typeof t=="object"||typeof t=="function"}function tt(t){return Object.keys(t).length===0}function et(t,...e){if(t==null)return k;const n=t.subscribe(...e);return n.unsubscribe?()=>n.unsubscribe():n}function nt(t,e,n){t.$$.on_destroy.push(et(e,n))}function st(t,e,n,s){if(t){const i=J(t,e,n,s);return t[0](i)}}function J(t,e,n,s){return t[1]&&s?X(n.ctx.slice(),t[1](s(e))):n.ctx}function it(t,e,n,s){if(t[2]&&s){const i=t[2](s(n));if(e.dirty===void 0)return i;if(typeof i=="object"){const a=[],u=Math.max(e.dirty.length,i.length);for(let c=0;c<u;c+=1)a[c]=e.dirty[c]|i[c];return a}return e.dirty|i}return e.dirty}function rt(t,e,n,s,i,a,u){const c=it(e,s,i,a);if(c){const m=J(e,n,s,u);t.p(m,c)}}function ct(t,e){t.appendChild(e)}function K(t,e,n){t.insertBefore(e,n||null)}function C(t){t.parentNode.removeChild(t)}function Q(t){return document.createElement(t)}function L(t){return document.createTextNode(t)}function ot(){return L(" ")}function ut(){return L("")}function at(t,e,n,s){return t.addEventListener(e,n,s),()=>t.removeEventListener(e,n,s)}function ft(t,e,n){n==null?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}function lt(t){return Array.from(t.childNodes)}function dt(t,e){e=""+e,t.wholeText!==e&&(t.data=e)}function ht(t,e,n){t.classList[n?"add":"remove"](e)}class _t{constructor(e=null){this.a=e,this.e=this.n=null}m(e,n,s=null){this.e||(this.e=Q(n.nodeName),this.t=n,this.h(e)),this.i(s)}h(e){this.e.innerHTML=e,this.n=Array.from(this.e.childNodes)}i(e){for(let n=0;n<this.n.length;n+=1)K(this.t,this.n[n],e)}p(e){this.d(),this.h(e),this.i(this.a)}d(){this.n.forEach(C)}}let R;function v(t){R=t}const x=[],T=[],E=[],H=[],gt=Promise.resolve();let O=!1;function pt(){O||(O=!0,gt.then(U))}function B(t){E.push(t)}function mt(t){H.push(t)}let q=!1;const z=new Set;function U(){if(q)return;q=!0;do{for(let t=0;t<x.length;t+=1){const e=x[t];v(e),yt(e.$$)}for(v(null),x.length=0;T.length;)T.pop()();for(let t=0;t<E.length;t+=1){const e=E[t];z.has(e)||(z.add(e),e())}E.length=0}while(x.length);for(;H.length;)H.pop()();O=!1,q=!1,z.clear()}function yt(t){if(t.fragment!==null){t.update(),b(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(B)}}const j=new Set;let p;function bt(){p={r:0,c:[],p}}function xt(){p.r||b(p.c),p=p.p}function P(t,e){t&&t.i&&(j.delete(t),t.i(e))}function wt(t,e,n,s){if(t&&t.o){if(j.has(t))return;j.add(t),p.c.push(()=>{j.delete(t),s&&(n&&t.d(1),s())}),t.o(e)}}function $t(t,e){t.d(1),e.delete(t.key)}function kt(t,e,n,s,i,a,u,c,m,o,y,d){let f=t.length,h=a.length,l=f;const A={};for(;l--;)A[t[l].key]=l;const w=[],M=new Map,S=new Map;for(l=h;l--;){const r=d(i,a,l),_=n(r);let g=u.get(_);g?s&&g.p(r,e):(g=o(_,r),g.c()),M.set(_,w[l]=g),_ in A&&S.set(_,Math.abs(l-A[_]))}const D=new Set,F=new Set;function N(r){P(r,1),r.m(c,y),u.set(r.key,r),y=r.first,h--}for(;f&&h;){const r=w[h-1],_=t[f-1],g=r.key,$=_.key;r===_?(y=r.first,f--,h--):M.has($)?!u.has(g)||D.has(g)?N(r):F.has($)?f--:S.get(g)>S.get($)?(F.add(g),N(r)):(D.add($),f--):(m(_,u),f--)}for(;f--;){const r=t[f];M.has(r.key)||m(r,u)}for(;h;)N(w[h-1]);return w}function vt(t,e,n){const s=t.$$.props[e];s!==void 0&&(t.$$.bound[s]=n,n(t.$$.ctx[s]))}function Et(t){t&&t.c()}function V(t,e,n){const{fragment:s,on_mount:i,on_destroy:a,after_update:u}=t.$$;s&&s.m(e,n),B(()=>{const c=i.map(G).filter(Y);a?a.push(...c):b(c),t.$$.on_mount=[]}),u.forEach(B)}function W(t,e){const n=t.$$;n.fragment!==null&&(b(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function jt(t,e){t.$$.dirty[0]===-1&&(x.push(t),pt(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function At(t,e,n,s,i,a,u=[-1]){const c=R;v(t);const m=e.props||{},o=t.$$={fragment:null,ctx:null,props:a,update:k,not_equal:i,bound:I(),on_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(c?c.$$.context:[]),callbacks:I(),dirty:u,skip_bound:!1};let y=!1;if(o.ctx=n?n(t,m,(d,f,...h)=>{const l=h.length?h[0]:f;return o.ctx&&i(o.ctx[d],o.ctx[d]=l)&&(!o.skip_bound&&o.bound[d]&&o.bound[d](l),y&&jt(t,d)),f}):[],o.update(),y=!0,b(o.before_update),o.fragment=s?s(o.ctx):!1,e.target){if(e.hydrate){const d=lt(e.target);o.fragment&&o.fragment.l(d),d.forEach(C)}else o.fragment&&o.fragment.c();e.intro&&P(t.$$.fragment),V(t,e.target,e.anchor),U()}v(c)}class Mt{$destroy(){W(this,1),this.$destroy=k}$on(e,n){const s=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return s.push(n),()=>{const i=s.indexOf(n);i!==-1&&s.splice(i,1)}}$set(e){this.$$set&&!tt(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}export{kt as A,rt as B,at as C,_t as H,Mt as S,ft as a,K as b,ct as c,C as d,Q as e,T as f,dt as g,ut as h,At as i,xt as j,nt as k,Et as l,W as m,k as n,bt as o,V as p,P as q,wt as r,Z as s,L as t,mt as u,vt as v,st as w,$t as x,ot as y,ht as z};
